# Nodejs-mvc
У моєму проєкті реалізована архітектура MVC, яка розділяє код на три чіткі частини: Model, View і Controller. Модель — це, наприклад, клас User, який визначає структуру користувача в базі даних і відповідає за збереження даних. Представлення (View) — це файли .ejs, які відповідають за інтерфейс користувача, наприклад сторінки реєстрації (register.ejs), логіну (login.ejs) чи дашборду (dashboard.ejs). Контролери, як-от registerUser чи loginUser, приймають HTTP-запити, отримують дані з форми, ініціюють виконання основних дій через відповідні команди і рендерять потрібний вигляд. Це розділення дозволяє чітко відокремити логіку роботи з даними, відображення та обробку запитів, що робить код структурованим і зручним для підтримки.

# Builder
Для створення об’єкта користувача я використовую патерн Builder. Замість того, щоб передавати всі параметри одразу у конструктор, застосовую окремий клас будівельника. Наприклад, у команді реєстрації я створюю користувача так:
```
const newUser = new User.Builder(this.name, this.email, this.password)
  .setLocation(this.location)
  .build();
```
Тут спочатку передаються обов’язкові параметри (ім’я, email, пароль), а потім викликається метод setLocation, який додає опціональну властивість, після чого методом build() повертається готовий об’єкт. Цей підхід робить код гнучким і розширюваним, оскільки можна легко додати нові параметри, не змінюючи конструктор основного класу.

# Command
Ще один ключовий патерн — Command. Я виніс логіку реєстрації та логіну в окремі класи RegisterUserCommand і LoginUserCommand, кожен з яких має метод execute(). Наприклад, у RegisterUserCommand відбувається валідація полів, перевірка унікальності email, хешування паролю і збереження користувача:
```
execute() {
  if (!this.name || !this.email || !this.password || !this.confirm) {
    return this.res.render("register", {
      name: this.name,
      email: this.email,
      location: this.location,
      error: "Please fill in all fields",
    });
  }
  if (this.password !== this.confirm) {
    return this.res.render("register", {
      name: this.name,
      email: this.email,
      location: this.location,
      error: "Passwords do not match",
    });
  }
  User.findOne({ email: this.email }).then(user => {
    if (user) {
      return this.res.render("register", {
        name: this.name,
        email: this.email,
        location: this.location,
        error: "Email already exists",
      });
    }
    const newUser = new User.Builder(this.name, this.email, this.password)
      .setLocation(this.location)
      .build();
    bcrypt.genSalt(10, (err, salt) =>
      bcrypt.hash(newUser.password, salt, (err, hash) => {
        if (err) throw err;
        newUser.password = hash;
        newUser.save()
          .then(() => this.res.redirect("/login"))
          .catch(err => console.log(err));
      })
    );
  });
}
```
Таким чином, команда інкапсулює всі кроки реєстрації і контролер просто створює об'єкт команди і виконує її. 
Це відокремлює валідацію полів, перевірку унікальності email та хешування пароля від обробки HTTP-запитів, покращує читабельність коду і спрощує його тестування.

# Теорія
Патерни проектування — це такі готові рішення для типових проблем, з якими стикаються програмісти під час створення програм. Вони допомагають писати код, який легко розуміти, змінювати і підтримувати. Патерни — це як шаблони, які можна використовувати багато разів у різних проєктах.

Є три основні типи патернів: ті, що допомагають створювати об’єкти (їх називають порожні), ті, що допомагають організувати взаємодію між класами і об’єктами (структурні), і ті, що допомагають організувати поведінку об’єктів, тобто як вони спілкуються між собою (поведінкові).

Ось основні патерни, які бувають:

Порожні (створення об’єктів):

Singleton (одиночка) — гарантує, що буде тільки один об’єкт певного класу.

Factory Method (фабричний метод) — створює об’єкти, але дозволяє підкласам вирішувати, який саме об’єкт створювати.

Abstract Factory (абстрактна фабрика) — створює сімейства пов’язаних об’єктів.

Builder (будівельник) — поступове створення складного об’єкта.

Prototype (прототип) — створення нових об’єктів копіюванням існуючих.

Структурні (організація об’єктів):

Adapter (адаптер) — дозволяє класам з різними інтерфейсами працювати разом.

Composite (композит) — представляє групу об’єктів як один об’єкт.

Decorator (декоратор) — додає нову поведінку об’єктам без зміни їх коду.

Facade (фасад) — спрощує складну систему, даючи простий інтерфейс.

Proxy (проксі) — створює замінник об’єкта, який контролює доступ до нього.

Поведінкові (взаємодія об’єктів):

Observer (спостерігач) — дозволяє повідомляти залежні об’єкти про зміни.

Strategy (стратегія) — дає змогу змінювати поведінку об’єкта під час роботи.

Command (команда) — інкапсулює запит як об’єкт, що дозволяє відкладати або чергувати дії.

Iterator (ітератор) — забезпечує послідовний доступ до елементів колекції.

State (стан) — змінює поведінку об’єкта залежно від його стану.

Це лише частина з усіх патернів, але вони найпопулярніші і найчастіше використовуються.